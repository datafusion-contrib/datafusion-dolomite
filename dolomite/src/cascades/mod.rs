//! Implementation of cascades style cost based optimizer.
//!
//! As its name says, the cascades optimizer is a cascades style cost based optimizer inspired by
//! orca[3] and columnbia project[4]. The cascades optimizer searches plan space following a
//! topdown approach, e.g. by applying transformations generated by rules. To avoid optimizing
//! some same subplan repeatedly, we use a memo data structure to store optimized plan for some
//! physical property. Also we follow orca's pattern to derive statistics on the fly.
//!
//! ## Memo
//!
//! Memo is a data structure used to efficiently store a forest of plans. It can be seen as a
//! single root of DAG(directed acyclic graph), where each node is a group. A group consists of
//! several logically equivalent expressions:
//!
//! 1. They have same logical properties, e.g. their schema are same.
//! 2. They have same statistics, e.g., their number of rows, distinct row count, are same.
//!
//! Each expression in group is called group expression. Each group expression is identified by
//! two parts: operator and inputs. The inputs of a group expression are groups. During
//! optimization, the optimizer need to create groups, insert group expression into groups
//! according to rules' result.
//!
//! Let's use a simple example to demonstrate memo changes driven by applying rules. The sql:
//! ```no
//! SELECT * FROM a, b WHERE a.x = b.x
//! ```
//! The initial memo created:
//!
//! ```no
//! G1: [InnerJoin(a.x = b.x) [G2 G3]]
//! G2: [TableScan(a)]
//! G3: [TableScan(b)]
//! ```
//!
//! After join commutativity transformation rule applied, G1 has two group expressions:
//!
//! ```no
//! G1: [InnerJoin(a.x = b.x) [G2 G3]] [InnerJoin(a.x = b.x) [G3 G2]]
//! G2: [TableScan(a)]
//! G3: [TableScan(b)]
//! ```
//!
//! ## Optimization Task
//!
//! The optimization process is heavily inspired by [Columnbia Project](https://github
//! .com/yongwen/columbia). The overall process is driven by tasks, which is scheduled by a
//! single thread, stack based scheduler, e.g. the tasks are executed in an FILO order. The
//! return result of a task has two cases:
//!
//! 1. `Done`: That means the task has finished and we should not put it back to stack, and
//! the scheduler should just go on with its successors.
//! 2. `Yield`: That means the task has not finished yet. The scheduler should put it back
//! into stack, and executes its dependencies first.
//!
#[allow(unused)]
mod memo;
pub use memo::*;
mod binding;
mod optimizer;
mod task;
pub use optimizer::*;
